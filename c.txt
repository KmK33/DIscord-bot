const { Client, GatewayIntentBits, ModalBuilder, Events, ActionRowBuilder, TextInputBuilder, TextInputStyle, EmbedBuilder, ButtonBuilder, ButtonStyle, messageLink, GuildMemberRoleManager, Collection } = require('discord.js')
const client = new Client({ intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent, GatewayIntentBits.GuildMessageReactions] });
const dotenv = require("dotenv")




dotenv.config({ path: './config.env' })

const token = process.env.BOT_TOKEN
const guildId = process.env.GUILD_ID
const roleId = process.env.ROLE_ID

const userVotes = new Map();
// const commandCooldowns = new Map();
const commandUsages = new Map();


const cooldownDuration = 10000;
const maxUsage = 2;










// Calculate the total number of votes
const addRoleToUser = (voteCounts, member, role) => {
    let winningOption = null;
    const totalVotes = Object.values(voteCounts).reduce((total, count) => total + count, 0);
    // console.log(totalVotes);

    if (totalVotes === 0) return winningOption = 'rejected 💥💥';


    // Calculate the percentage of votes for each option
    const percentageOption1 = (voteCounts.option1 / totalVotes) * 100;
    const percentageOption2 = (voteCounts.option2 / totalVotes) * 100;
    voteCounts.option1 = percentageOption1
    voteCounts.option2 = percentageOption2



    // Determine the winning option

    if (percentageOption1 >= 69) {
        winningOption = 'approved 💚💚';
        member.roles.add(role);

    } else if (percentageOption2 >= 69) {
        winningOption = 'rejected 💥💥';
    }
    else if (percentageOption1 === percentageOption2) {
        winningOption = 'rejected 💥💥';
    }
    if (winningOption) return winningOption

    return winningOption = null
    // console.log(`Winning option with 69% or more votes: ${winningOption}`);
}





// EVENT LISTNERS
client.on('ready', () => {
    try {

        console.log(`Logged in as ${client.user.tag}`);
    } catch (err) {
        console.log(err);
    }


});
//TEST
client.on('messageCreate', (message) => {

    if (message.content === '!test') {
        const embed = new EmbedBuilder()
            .setColor('#0099ff')
            .setTitle('Apply Now')
            .setDescription('Click the button below to apply.')
            .setFooter({ text: 'Test Embed' });

        // Create the button
        const applyButton = new ButtonBuilder()
            .setCustomId('applyButton')
            .setLabel('Apply')
            .setStyle(ButtonStyle.Success);

        const actionRow = new ActionRowBuilder().addComponents(applyButton);

        // Send the embed message with the button
        message.channel.send({ embeds: [embed], components: [actionRow] });

    }



})

client.on(Events.InteractionCreate, async (interaction) => {
    try {

        if (!interaction.isButton()) return;

        if (interaction.customId === 'applyButton') {
            const guild = interaction.guild;
            const memberId = interaction.user.id;
            const member = guild.members.cache.get(memberId);

            if (member.roles.cache.some(role => role.name === 'tester')) {
                return interaction.reply({ content: 'You are already approved -_-', ephemeral: true })
            }



            let commandUsageCount = commandUsages.get(interaction.user.id) || 0;
            if (commandUsageCount >= maxUsage) {
                await interaction.reply({ content: 'You have reached the limit for applying the form .', ephemeral: true });
                return;
            }

            // if (commandCooldowns.has(interaction.user.id)) {
            //     const cooldownEnd = commandCooldowns.get(interaction.user.id);
            //     const remainingTime = cooldownEnd - Date.now();

            //     // Command is still on cooldown
            //     return interaction.reply(`Too fast there. Please wait ${Math.ceil(remainingTime / 1000)} seconds before using it again.`);
            // }


            // Create the modal
            const modal = new ModalBuilder()
                .setCustomId('myModal')
                .setTitle('Apply Form');



            // Create the text input components
            const twitterHandleInput = new TextInputBuilder()
                .setCustomId('twitterHandleInput')
                // The label is the prompt the user sees for this input
                .setLabel("Twitter Username (@)")
                // Short means only a single line of text
                .setStyle(TextInputStyle.Short);

            const discordId = new TextInputBuilder()
                .setCustomId('discordId')
                .setLabel("Discord Username")
                .setStyle(TextInputStyle.Short);

            const userAbout = new TextInputBuilder()
                .setCustomId('userAbout')
                .setLabel("Tell us about yourself ?")
                .setStyle(TextInputStyle.Paragraph)
                .setMaxLength(750)

            const skillsAbout = new TextInputBuilder()
                .setCustomId('skillsAbout')
                .setLabel("Flex your skills & contributions to ecosystem")
                .setStyle(TextInputStyle.Paragraph)
                .setMaxLength(750)

            const q5 = new TextInputBuilder()
                .setCustomId('q5')
                .setLabel("q5 ")
                .setStyle(TextInputStyle.Paragraph)
                .setMaxLength(750)


            // An action row only holds one text input,
            // so you need one action row per text input.
            const firstActionRow = new ActionRowBuilder().addComponents(twitterHandleInput);
            const secondActionRow = new ActionRowBuilder().addComponents(discordId);
            const thirdActionRow = new ActionRowBuilder().addComponents(userAbout);
            const fourthActionRow = new ActionRowBuilder().addComponents(skillsAbout);
            const fifthActionRow = new ActionRowBuilder().addComponents(q5);
            // Add inputs to the modal
            modal.addComponents(secondActionRow, firstActionRow, thirdActionRow, fourthActionRow, fifthActionRow);

            // Show the modal to the user
            await interaction.showModal(modal);

            // const cooldownEnd = Date.now() + cooldownDuration
            // commandCooldowns.set(interaction.user.id, cooldownEnd)

            // setTimeout(() => {
            //     commandCooldowns.delete(interaction.user.id);
            // }, cooldownDuration);


        }

        // if (interaction.commandName === 'react') {
        //     interaction.reply('Reacting with fruits!');
        //     const message = await interaction.fetchReply();
        //     message.react('🍎');
        //     message.react('🍊');
        //     message.react('🍇');
        // }



    } catch (err) {
        console.log(err);
    }
})




//MODAL CREATE
client.on(Events.InteractionCreate, async (interaction) => {
    try {

        if (!interaction.isChatInputCommand()) return;
        // console.log(interaction.user.id);

        if (interaction.commandName === 'apply') {
            const guild = interaction.guild;
            const memberId = interaction.user.id;
            const member = guild.members.cache.get(memberId);

            if (member.roles.cache.some(role => role.name === 'tester')) {
                return interaction.reply('You are already approved -_-')
            }



            let commandUsageCount = commandUsages.get(interaction.user.id) || 0;
            if (commandUsageCount >= maxUsage) {
                await interaction.reply('You have reached the limit for applying the form .');
                return;
            }

            if (commandCooldowns.has(interaction.user.id)) {
                const cooldownEnd = commandCooldowns.get(interaction.user.id);
                const remainingTime = cooldownEnd - Date.now();

                // Command is still on cooldown
                return interaction.reply(`Too fast there. Please wait ${Math.ceil(remainingTime / 1000)} seconds before using it again.`);
            }


            // Create the modal
            const modal = new ModalBuilder()
                .setCustomId('myModal')
                .setTitle('Apply Form');



            // Create the text input components
            const twitterHandleInput = new TextInputBuilder()
                .setCustomId('twitterHandleInput')
                // The label is the prompt the user sees for this input
                .setLabel("Twitter Username (@)")
                // Short means only a single line of text
                .setStyle(TextInputStyle.Short);

            const discordId = new TextInputBuilder()
                .setCustomId('discordId')
                .setLabel("Discord Username")
                .setStyle(TextInputStyle.Short);

            const userAbout = new TextInputBuilder()
                .setCustomId('userAbout')
                .setLabel("Tell us about yourself ?")
                .setStyle(TextInputStyle.Paragraph)
                .setMaxLength(750)

            const skillsAbout = new TextInputBuilder()
                .setCustomId('skillsAbout')
                .setLabel("Flex your skills & contributions to ecosystem")
                .setStyle(TextInputStyle.Paragraph)
                .setMaxLength(750)

            const q5 = new TextInputBuilder()
                .setCustomId('q5')
                .setLabel("q5 ")
                .setStyle(TextInputStyle.Paragraph)
                .setMaxLength(750)


            // An action row only holds one text input,
            // so you need one action row per text input.
            const firstActionRow = new ActionRowBuilder().addComponents(twitterHandleInput);
            const secondActionRow = new ActionRowBuilder().addComponents(discordId);
            const thirdActionRow = new ActionRowBuilder().addComponents(userAbout);
            const fourthActionRow = new ActionRowBuilder().addComponents(skillsAbout);
            const fifthActionRow = new ActionRowBuilder().addComponents(q5);
            // Add inputs to the modal
            modal.addComponents(firstActionRow, secondActionRow, thirdActionRow, fourthActionRow, fifthActionRow);

            // Show the modal to the user
            await interaction.showModal(modal);

            const cooldownEnd = Date.now() + cooldownDuration
            commandCooldowns.set(interaction.user.id, cooldownEnd)

            setTimeout(() => {
                commandCooldowns.delete(interaction.user.id);
            }, cooldownDuration);


        }

        // if (interaction.commandName === 'react') {
        //     interaction.reply('Reacting with fruits!');
        //     const message = await interaction.fetchReply();
        //     message.react('🍎');
        //     message.react('🍊');
        //     message.react('🍇');
        // }





    } catch (err) {
        console.log(err);
    }





})

//MODAL SUMBIT
client.on(Events.InteractionCreate, async interaction => {
    try {

        //interaction.user.id =  '1232131230517202972'
        if (!interaction.isModalSubmit()) return;

        if (interaction.customId === 'myModal') {
            //INCREASING USAGE OF FORM
            let commandUsagesCount = commandUsages.get(interaction.user.id) || 0;
            commandUsagesCount++;
            commandUsages.set(interaction.user.id, commandUsagesCount)

            console.log(commandUsagesCount, commandUsages);



            // console.log(interaction);

            const twitterIdOutput = interaction.fields.getTextInputValue('twitterHandleInput')
            const discordIdOutput = interaction.fields.getTextInputValue('discordId')
            const userAboutOutput = interaction.fields.getTextInputValue('userAbout')
            const skillsAboutOutput = interaction.fields.getTextInputValue('skillsAbout')
            const q5Output = interaction.fields.getTextInputValue('q5')

            let userOutputEmbed, actionRow, approveButton, rejectButton

            userOutputEmbed = new EmbedBuilder()
                .setColor('Random')
                .setTitle(`Twitter : https://twitter.com/${twitterIdOutput}`)
                .setURL(`https://twitter.com/${twitterIdOutput}`)
                .setAuthor({ name: `YOUR CLICK WILL ONLY BE COUNT ONCE` })
                .setDescription(' YOUR VOTE WILL ONLY BE COUNT(one click on any button) ONCE SO MAKE SURE TO VOTE CAREFULLY! ')
                .addFields(
                    { name: '\u200B', value: '\u200B' },
                    { name: '<QUESTION>', value: `${q5Output}` },
                    { name: '\u200B', value: '\u200B' },
                    { name: 'The user  :', value: `${userAboutOutput}` },
                    { name: '\u200B', value: '\u200B' },
                    { name: 'User skills and contributions :', value: `${skillsAboutOutput}`, inline: true },
                    { name: '\u200B', value: '\u200B' }
                )
                .setTimestamp()



            approveButton = new ButtonBuilder()
                .setCustomId('approve')
                .setLabel('APPROVE')
                .setStyle(ButtonStyle.Primary);

            rejectButton = new ButtonBuilder()
                .setCustomId('reject')
                .setLabel('REJECT')
                .setStyle(ButtonStyle.Danger);

            actionRow = new ActionRowBuilder()
                .addComponents(approveButton, rejectButton);

            if (commandUsagesCount === 1) {
                userOutputEmbed.setFooter({ text: " helllo" })


            } else if (commandUsagesCount >= 2) {
                userOutputEmbed.setFooter({ text: 'This user has reapplied' })

            }




            const targetChannel = client.channels.cache.get('1116416945676365915')

            const pollMessage = await targetChannel.send({ embeds: [userOutputEmbed], components: [actionRow] });

            const voteCounts = {
                option1: 0,
                option2: 0,
            };



            const filter = (interaction) => interaction.isButton() && interaction.message.id === pollMessage.id;
            const collector = pollMessage.createMessageComponentCollector({ filter, time: 20000 }); // Adjust the time according to your needs



            collector.on('collect', (interaction) => {
                const { customId, user } = interaction;

                if (userVotes.has(user.id)) {
                    return;
                }

                // Process the vote based on the customId
                if (customId === 'approve') {
                    interaction.reply({ content: `You have selected 'APPROVE'`, ephemeral: true });
                    // Process vote for Option 1
                    voteCounts.option1++
                } else if (customId === 'reject') {
                    interaction.reply({ content: `You have selected 'REJECT'`, ephemeral: true });
                    // Process vote for Option 2
                    voteCounts.option2++
                }

                userVotes.set(user.id, true);

                //  interaction.reply(`You voted for ${customId}`);
            });

            collector.on('end', () => {
                // console.log(interaction);

                const guild = interaction.guild;
                const memberId = interaction.user.id;

                const member = guild.members.cache.get(memberId);
                const role = guild.roles.cache.get(roleId);


                const winningOption = addRoleToUser(voteCounts, member, role)
                // console.log(winningOption);


                // Disable the buttons after the collection ends
                approveButton.setDisabled(true);
                rejectButton.setDisabled(true);
                actionRow.components = [approveButton, rejectButton];
                pollMessage.edit({ components: [actionRow] });
                //pollMessage.delete()
                let resultEmbed;
                if (winningOption.startsWith('approved')) {

                    resultEmbed = new EmbedBuilder().setColor('Green').setTitle(`Results for user : @${discordIdOutput}`).addFields({ name: 'Approve', value: `${voteCounts.option1} %` }).addFields({ name: 'Reject', value: `${voteCounts.option2} %` }, { name: 'Result', value: `${winningOption}` }).setFooter({ text: "Special role will be granted starting today" });
                } else {
                    resultEmbed = new EmbedBuilder().setColor('Red').setTitle(`Results for user : @${discordIdOutput}`).addFields({ name: 'Approve', value: `${voteCounts.option1} %` }).addFields({ name: 'Reject', value: `${voteCounts.option2} %` }, { name: 'Result', value: `${winningOption}` });

                }

                targetChannel.send({ embeds: [resultEmbed] });

                userVotes.clear();
            });

            interaction.reply({ content: `@${interaction.user.username} successfully applied`, ephemeral: true })

        }
    } catch (err) {
        console.log(err);

    }
});








client.login(token);
